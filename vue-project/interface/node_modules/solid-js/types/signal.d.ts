export declare const equalFn: <T>(a: T, b: T) => boolean;
declare let Owner: Owner | null;
interface Signal<T> {
    value?: T;
    observers: Computation<any>[] | null;
    observerSlots: number[] | null;
    pending: T | {};
    comparator?: (prev: T, next: T) => boolean;
}
interface Owner {
    owned: Computation<any>[] | null;
    cleanups: (() => void)[] | null;
    owner?: Owner | null;
    context: any | null;
}
interface Computation<T> extends Owner {
    fn: (v?: T) => T;
    state: number;
    sources: Signal<T>[] | null;
    sourceSlots: number[] | null;
    value?: T;
    updatedAt: number | null;
}
export declare function createRoot<T>(fn: (dispose: () => void) => T, detachedOwner?: Owner): T;
export declare function createSignal<T>(value?: T, areEqual?: (prev: T, next: T) => boolean): [() => T, (v: T) => void];
export declare function createEffect<T>(fn: (v?: T) => T, value?: T): void;
export declare function createDependentEffect<T>(fn: (v?: T) => T, deps: (() => any) | (() => any)[], defer?: boolean): void;
export declare function createMemo<T>(fn: (v?: T) => T, value?: T, areEqual?: (prev: T, next: T) => boolean): () => T;
export declare function createDeferred<T>(fn: () => T, options?: {
    timeoutMs: number;
}): () => T;
export declare function freeze<T>(fn: () => T): T;
export declare function sample<T>(fn: () => T): T;
export declare function afterEffects(fn: () => void): void;
export declare function onCleanup(fn: () => void): () => void;
export declare function onError(fn: (err: any) => void): void;
export declare function isListening(): boolean;
export interface Context<T> {
    id: symbol;
    Provider: (props: {
        value: T;
        children: any;
    }) => any;
    defaultValue?: T;
}
export declare function createContext<T>(defaultValue?: T): Context<T>;
export declare function useContext<T>(context: Context<T>): T;
export declare function getContextOwner(): Owner | null;
export {};
