export * from 'solid-js';
export * from 'solid-js/dom';
export interface ReactiveVariable<T> {
    (value?: undefined): T;
    (value: T): void;
}
/** Represents a reactive variable. The value is set or gotten depending on passing an arg or no arg. */
export interface Variable<T = any> {
    /** Gets the variable value. */
    (value?: undefined): T;
    /** Sets the variable value. */
    (value: T): T;
    (value?: T): void | T;
    get(): T;
    set(value: T): T;
}
/**
 * Create a reactive variable.
 *
 * @example
 * let count = variable(0) // count starts at 0
 * count(1) // set the value of count to 1
 * count(count() + 1) // add 1
 * let currentValue = count() // read the current value
 * console.log(currentValue) // logs "2" to console
 */
export declare function variable<T>(value: T): Variable<T>;
export declare type Computation = (previousValue?: unknown) => unknown;
export declare type StopFunction = () => void;
/**
 * Automatically run a "computation" when any reactive variable used inside the
 * computation has changed. The "computation" is a function passed into
 * autorun().
 *
 * @param {Computation} f - A "computation" to re-run when any of the reactive
 * variables used inside of it change.
 * @return {StopFunction} - Returns a function that can be called to explicitly
 * stop the computation from running, allowing it to be garbage collected.
 */
export declare function autorun(f: Computation): StopFunction;
export declare function reactive<T>(prototype: any, name: string, descriptor?: PropertyDescriptor): any;
export declare const version = "0.0.8";
